{"version":3,"sources":["meteor://ðŸ’»app/packages/jaywon_meteor-node-uuid/packages/jaywon_meteor-node-uuid.js"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG","file":"/packages/jaywon_meteor-node-uuid.js","sourcesContent":["(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/jaywon:meteor-node-uuid/node-uuid/uuid.js                              //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\n//     uuid.js                                                                     // 1\n//                                                                                 // 2\n//     Copyright (c) 2010-2012 Robert Kieffer                                      // 3\n//     MIT License - http://opensource.org/licenses/mit-license.php                // 4\n                                                                                   // 5\n(function() {                                                                      // 6\n  var _global = this;                                                              // 7\n                                                                                   // 8\n  // Unique ID creation requires a high quality random # generator.  We feature    // 9\n  // detect to determine the best RNG source, normalizing to a function that       // 10\n  // returns 128-bits of randomness, since that's what's usually required          // 11\n  var _rng;                                                                        // 12\n                                                                                   // 13\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html      // 14\n  //                                                                               // 15\n  // Moderately fast, high quality                                                 // 16\n  if (typeof(_global.require) == 'function') {                                     // 17\n    try {                                                                          // 18\n      var _rb = _global.require('crypto').randomBytes;                             // 19\n      _rng = _rb && function() {return _rb(16);};                                  // 20\n    } catch(e) {}                                                                  // 21\n  }                                                                                // 22\n                                                                                   // 23\n  if (!_rng && _global.crypto && crypto.getRandomValues) {                         // 24\n    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto                // 25\n    //                                                                             // 26\n    // Moderately fast, high quality                                               // 27\n    var _rnds8 = new Uint8Array(16);                                               // 28\n    _rng = function whatwgRNG() {                                                  // 29\n      crypto.getRandomValues(_rnds8);                                              // 30\n      return _rnds8;                                                               // 31\n    };                                                                             // 32\n  }                                                                                // 33\n                                                                                   // 34\n  if (!_rng) {                                                                     // 35\n    // Math.random()-based (RNG)                                                   // 36\n    //                                                                             // 37\n    // If all else fails, use Math.random().  It's fast, but is of unspecified     // 38\n    // quality.                                                                    // 39\n    var  _rnds = new Array(16);                                                    // 40\n    _rng = function() {                                                            // 41\n      for (var i = 0, r; i < 16; i++) {                                            // 42\n        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;                     // 43\n        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;                                 // 44\n      }                                                                            // 45\n                                                                                   // 46\n      return _rnds;                                                                // 47\n    };                                                                             // 48\n  }                                                                                // 49\n                                                                                   // 50\n  // Buffer class to use                                                           // 51\n  var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array; // 52\n                                                                                   // 53\n  // Maps for number <-> hex string conversion                                     // 54\n  var _byteToHex = [];                                                             // 55\n  var _hexToByte = {};                                                             // 56\n  for (var i = 0; i < 256; i++) {                                                  // 57\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);                            // 58\n    _hexToByte[_byteToHex[i]] = i;                                                 // 59\n  }                                                                                // 60\n                                                                                   // 61\n  // **`parse()` - Parse a UUID into it's component bytes**                        // 62\n  function parse(s, buf, offset) {                                                 // 63\n    var i = (buf && offset) || 0, ii = 0;                                          // 64\n                                                                                   // 65\n    buf = buf || [];                                                               // 66\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {                        // 67\n      if (ii < 16) { // Don't overflow!                                            // 68\n        buf[i + ii++] = _hexToByte[oct];                                           // 69\n      }                                                                            // 70\n    });                                                                            // 71\n                                                                                   // 72\n    // Zero out remaining bytes if string was short                                // 73\n    while (ii < 16) {                                                              // 74\n      buf[i + ii++] = 0;                                                           // 75\n    }                                                                              // 76\n                                                                                   // 77\n    return buf;                                                                    // 78\n  }                                                                                // 79\n                                                                                   // 80\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**         // 81\n  function unparse(buf, offset) {                                                  // 82\n    var i = offset || 0, bth = _byteToHex;                                         // 83\n    return  bth[buf[i++]] + bth[buf[i++]] +                                        // 84\n            bth[buf[i++]] + bth[buf[i++]] + '-' +                                  // 85\n            bth[buf[i++]] + bth[buf[i++]] + '-' +                                  // 86\n            bth[buf[i++]] + bth[buf[i++]] + '-' +                                  // 87\n            bth[buf[i++]] + bth[buf[i++]] + '-' +                                  // 88\n            bth[buf[i++]] + bth[buf[i++]] +                                        // 89\n            bth[buf[i++]] + bth[buf[i++]] +                                        // 90\n            bth[buf[i++]] + bth[buf[i++]];                                         // 91\n  }                                                                                // 92\n                                                                                   // 93\n  // **`v1()` - Generate time-based UUID**                                         // 94\n  //                                                                               // 95\n  // Inspired by https://github.com/LiosK/UUID.js                                  // 96\n  // and http://docs.python.org/library/uuid.html                                  // 97\n                                                                                   // 98\n  // random #'s we need to init node and clockseq                                  // 99\n  var _seedBytes = _rng();                                                         // 100\n                                                                                   // 101\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)      // 102\n  var _nodeId = [                                                                  // 103\n    _seedBytes[0] | 0x01,                                                          // 104\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]      // 105\n  ];                                                                               // 106\n                                                                                   // 107\n  // Per 4.2.2, randomize (14 bit) clockseq                                        // 108\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;                   // 109\n                                                                                   // 110\n  // Previous uuid creation time                                                   // 111\n  var _lastMSecs = 0, _lastNSecs = 0;                                              // 112\n                                                                                   // 113\n  // See https://github.com/broofa/node-uuid for API details                       // 114\n  function v1(options, buf, offset) {                                              // 115\n    var i = buf && offset || 0;                                                    // 116\n    var b = buf || [];                                                             // 117\n                                                                                   // 118\n    options = options || {};                                                       // 119\n                                                                                   // 120\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;        // 121\n                                                                                   // 122\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,        // 123\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so           // 124\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'    // 125\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.     // 126\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();      // 127\n                                                                                   // 128\n    // Per 4.2.1.2, use count of uuid's generated during the current clock         // 129\n    // cycle to simulate higher resolution clock                                   // 130\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;            // 131\n                                                                                   // 132\n    // Time since last uuid creation (in msecs)                                    // 133\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;                    // 134\n                                                                                   // 135\n    // Per 4.2.1.2, Bump clockseq on clock regression                              // 136\n    if (dt < 0 && options.clockseq == null) {                                      // 137\n      clockseq = clockseq + 1 & 0x3fff;                                            // 138\n    }                                                                              // 139\n                                                                                   // 140\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new     // 141\n    // time interval                                                               // 142\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {                 // 143\n      nsecs = 0;                                                                   // 144\n    }                                                                              // 145\n                                                                                   // 146\n    // Per 4.2.1.2 Throw error if too many uuids are requested                     // 147\n    if (nsecs >= 10000) {                                                          // 148\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');         // 149\n    }                                                                              // 150\n                                                                                   // 151\n    _lastMSecs = msecs;                                                            // 152\n    _lastNSecs = nsecs;                                                            // 153\n    _clockseq = clockseq;                                                          // 154\n                                                                                   // 155\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch                      // 156\n    msecs += 12219292800000;                                                       // 157\n                                                                                   // 158\n    // `time_low`                                                                  // 159\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;                  // 160\n    b[i++] = tl >>> 24 & 0xff;                                                     // 161\n    b[i++] = tl >>> 16 & 0xff;                                                     // 162\n    b[i++] = tl >>> 8 & 0xff;                                                      // 163\n    b[i++] = tl & 0xff;                                                            // 164\n                                                                                   // 165\n    // `time_mid`                                                                  // 166\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;                           // 167\n    b[i++] = tmh >>> 8 & 0xff;                                                     // 168\n    b[i++] = tmh & 0xff;                                                           // 169\n                                                                                   // 170\n    // `time_high_and_version`                                                     // 171\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version                           // 172\n    b[i++] = tmh >>> 16 & 0xff;                                                    // 173\n                                                                                   // 174\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)                   // 175\n    b[i++] = clockseq >>> 8 | 0x80;                                                // 176\n                                                                                   // 177\n    // `clock_seq_low`                                                             // 178\n    b[i++] = clockseq & 0xff;                                                      // 179\n                                                                                   // 180\n    // `node`                                                                      // 181\n    var node = options.node || _nodeId;                                            // 182\n    for (var n = 0; n < 6; n++) {                                                  // 183\n      b[i + n] = node[n];                                                          // 184\n    }                                                                              // 185\n                                                                                   // 186\n    return buf ? buf : unparse(b);                                                 // 187\n  }                                                                                // 188\n                                                                                   // 189\n  // **`v4()` - Generate random UUID**                                             // 190\n                                                                                   // 191\n  // See https://github.com/broofa/node-uuid for API details                       // 192\n  function v4(options, buf, offset) {                                              // 193\n    // Deprecated - 'format' argument, as supported in v1.2                        // 194\n    var i = buf && offset || 0;                                                    // 195\n                                                                                   // 196\n    if (typeof(options) == 'string') {                                             // 197\n      buf = options == 'binary' ? new BufferClass(16) : null;                      // 198\n      options = null;                                                              // 199\n    }                                                                              // 200\n    options = options || {};                                                       // 201\n                                                                                   // 202\n    var rnds = options.random || (options.rng || _rng)();                          // 203\n                                                                                   // 204\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`               // 205\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;                                             // 206\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;                                             // 207\n                                                                                   // 208\n    // Copy bytes to buffer, if provided                                           // 209\n    if (buf) {                                                                     // 210\n      for (var ii = 0; ii < 16; ii++) {                                            // 211\n        buf[i + ii] = rnds[ii];                                                    // 212\n      }                                                                            // 213\n    }                                                                              // 214\n                                                                                   // 215\n    return buf || unparse(rnds);                                                   // 216\n  }                                                                                // 217\n                                                                                   // 218\n  // Export public API                                                             // 219\n  var uuid = v4;                                                                   // 220\n  uuid.v1 = v1;                                                                    // 221\n  uuid.v4 = v4;                                                                    // 222\n  uuid.parse = parse;                                                              // 223\n  uuid.unparse = unparse;                                                          // 224\n  uuid.BufferClass = BufferClass;                                                  // 225\n                                                                                   // 226\n  if (typeof define === 'function' && define.amd) {                                // 227\n    // Publish as AMD module                                                       // 228\n    define(function() {return uuid;});                                             // 229\n  } else if (typeof(module) != 'undefined' && module.exports) {                    // 230\n    // Publish as node.js module                                                   // 231\n    module.exports = uuid;                                                         // 232\n  } else {                                                                         // 233\n    // Publish as global (in browsers)                                             // 234\n    var _previousRoot = _global.uuid;                                              // 235\n                                                                                   // 236\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**              // 237\n    uuid.noConflict = function() {                                                 // 238\n      _global.uuid = _previousRoot;                                                // 239\n      return uuid;                                                                 // 240\n    };                                                                             // 241\n                                                                                   // 242\n    _global.uuid = uuid;                                                           // 243\n  }                                                                                // 244\n}).call(this);                                                                     // 245\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}